# Отчёт по измерительным методам оценки программного обеспечения

## Теоретическая часть

### 1. Определение и цели

**Измерительные методы оценки программ** - это количественные подходы к анализу характеристик программного обеспечения с использованием метрик. Они позволяют объективно оценивать различные аспекты кода, такие как размер, сложность, качество и поддерживаемость.

**Основные цели применения:**
- Оценка сложности кода и выявление потенциально проблемных участков
- Контроль качества программного обеспечения
- Прогнозирование трудозатрат на сопровождение и модификацию
- Сравнение альтернативных реализаций
- Выявление областей для рефакторинга и оптимизации
- Обеспечение стандартов кодирования в команде

### 2. Примеры метрик

**Метрики размера:**
- **Количество строк кода (SLOC)** - оценивает объем программы, используется для оценки трудозатрат
- **Количество функций/методов** - показывает модульность кода, помогает оценить уровень абстракции

**Метрики сложности:**
- **Цикломатическая сложность** - измеряет количество линейно независимых путей в коде, помогает выявить переусложненные функции

**Метрики качества:**
- **Коэффициент сопровождения** - оценивает легкость поддержки кода (обычно учитывает сложность и объем)
- **Покрытие тестами** - показывает процент кода, выполненного тестами, индикатор надежности

### 3. Условия применения и ограничения

**Условия применения:**
- При рефакторинге для выявления проблемных участков
- В процессе код-ревью для объективной оценки
- При долгосрочном сопровождении для контроля качества
- Для сравнения альтернативных реализаций

**Ограничения:**
- Метрики не всегда отражают реальную сложность или качество
- Могут давать ложное чувство объективности
- Требуют контекстной интерпретации
- Некоторые метрики зависят от языка программирования
- Чрезмерное увлечение метриками может привести к "оптимизации" метрик вместо реального улучшения кода

## Практическая часть: анализ кода на основе файлов test2.py и cb2.py

### Анализ файла test2.py

#### 1. Метрики размера
- Количество строк кода (без пустых строк и комментариев): 11
- Количество функций: 3 (calculate_sum, factorial, print_numbers)

#### 2. Цикломатическая сложность функций
1. calculate_sum(a, b):
   - Ветвления: 0
   - Сложность: 1 (базовый уровень)

2. factorial(n):
   - Ветвления: 1 (if-else)
   - Сложность: 2

3. print_numbers(n):
   - Ветвления: 1 (if-else внутри цикла)
   - Сложность: 2 (цикл + условие)

#### 3. Выводы по test2.py
- Самая сложная функция: print_numbers и factorial имеют одинаковую цикломатическую сложность (2), но print_numbers содержит дополнительную сложность из-за цикла.
- Потенциальные проблемы:
  - В factorial возможна рекурсия без ограничения глубины для отрицательных чисел
  - В print_numbers могут быть проблемы с большими значениями n из-за вывода в консоль

### Анализ файла cb2.py

#### 1. Метрики размера
- Количество строк кода (без пустых строк и комментариев): 97
- Количество функций: 1 (основной скрипт без явных функций)

#### 2. Цикломатическая сложность
Основная сложность сосредоточена в блоках:
1. Основной цикл while: +1
2. Условие проверки статуса ответа: +1
3. Вложенный цикл for по валютам: +1
4. Условие проверки валюты: +1
5. Условие проверки пустого DataFrame: +1 (в двух местах)

Общая оценка сложности: ~5-6 (из-за вложенных структур)

#### 3. Выводы по cb2.py
- Критические участки:
  1. Сложная логика обработки XML и нормализации данных
  2. Множественные вложенные блоки обработки данных
  3. Отсутствие явного разделения на функции (высокая связность)

- Потенциальные проблемы:
  - Обработка ошибок сети и невалидных XML
  - Проблемы с производительностью при большом диапазоне дат
  - Отсутствие модульности кода

### Сравнительный анализ

| Метрика               | test2.py | cb2.py |
|-----------------------|----------|--------|
| Строк кода            | 11       | 97     |
| Функций               | 3        | 1*     |
| Макс. сложность       | 2        | 5-6    |
| Основные риски        | Рекурсия, вывод | Сложность, обработка ошибок |

*В cb2.py код представлен как скрипт без явных функций

### Рекомендации по улучшению

Для test2.py:
1. Добавить проверку отрицательных чисел в factorial
2. Ограничить вывод в print_numbers при больших n
3. Вынести константные строки ("is even"/"is odd") в переменные

Для cb2.py:
1. Разделить код на отдельные функции:
   - fetch_currency_data()
   - parse_xml_response()
   - save_to_excel()
   - plot_currency_trend()
2. Добавить обработку ошибок (try-except для запросов)
3. Реализовать кэширование запросов к API
4. Вынести конфигурационные параметры (url, currencies) в отдельный блок

Общие рекомендации:
1. Добавить модульные тесты для ключевых функций
2. Реализовать логирование важных событий
3. Для cb2.py рассмотреть использование классов для организации кода

### Пример улучшенной структуры для cb2.py (фрагмент)

`python
def fetch_currency_data(start_date, end_date, currencies):
    """Получение данных о курсах валют за период"""
    data = {currency: [] for currency in currencies}
    current_date = start_date
    
    while current_date <= end_date:
        formatted_date = current_date.strftime('%d/%m/%Y')
        url = f"https://www.cbr.ru/scripts/XML_daily.asp?date_req={formatted_date}"
        
        try:
            response = requests.get(url)
            response.encoding = 'windows-1251'
            if response.status_code == 200:
                parse_xml_response(response.content, data, currencies)
        except requests.RequestException as e:
            logging.error(f"Ошибка запроса для {formatted_date}: {e}")
        
        current_date += timedelta(days=1)
    
    return data
def parse_xml_response(xml_content, data, currencies):
    """Парсинг XML ответа от ЦБ"""
    root = ET.fromstring(xml_content)
    date_record = root.attrib.get('Date')
    
    for valute in root.findall('Valute'):
        char_code = valute.find('CharCode').text
        if char_code in currencies:
            value = float(valute.find('Value').text.replace(',', '.'))
            nominal = int(valute.find('Nominal').text)
            normalized_value = value / nominal
            
            data[char_code].append({
                'date': date_record,
                'value': normalized_value
            })
`

Такой подход значительно улучшит читаемость и поддерживаемость кода, а также упростит тестирование отдельных компонентов.

### Расчет метрик

**test1.py:**
1. Метрики размера:
   - Строк кода: 8 (без пустых строк и комментариев)
   - Количество функций: 3

2. Цикломатическая сложность:
   - calculate_sum: 1 (нет ветвлений)
   - calculate_product: 1 (нет ветвлений)
   - is_even: 2 (1 ветвление if-else)

**test2.py:**
1. Метрики размера:
   - Строк кода: 16 (без пустых строк и комментариев)
   - Количество функций: 2

2. Цикломатическая сложность:
   - process_data: 4 (2 вложенных if-else)
   - validate_input: 3 (1 try-except + 1 if)

### Выводы

1. **Самая сложная функция** - `process_data` из test2.py с цикломатической сложностью 4. Это связано с вложенными условиями и множественными путями выполнения.

2. **Потенциальные места для ошибок**:
   - В функции `process_data` сложная логика обработки данных с множественными условиями
   - В функции `validate_input` возможны проблемы с обработкой различных типов входных данных

3. **Рекомендации по улучшению**:
   - Упростить `process_data`, разбив на несколько более простых функций
   - Добавить обработку дополнительных крайних случаев в `validate_input`
   - Увеличить покрытие тестами, особенно для сложных функций
   - Рассмотреть возможность использования guard clauses для упрощения сложных условий

## Заключение

Измерительные методы предоставляют ценные инструменты для объективной оценки программного кода. Как показал анализ, даже в простых примерах метрики помогают выявить потенциально проблемные участки кода. Однако важно помнить, что метрики - это лишь инструмент, и их следует использовать в сочетании с профессиональным суждением и другими методами оценки качества кода.
